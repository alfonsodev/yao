package {{.Schema}}

import(
	"fmt"
	"reflect"
	"database/sql/driver"
)

type Modeler interface {
	Save() (*sql.Rows, error)
}

type Query struct {
        Schema string
        Table string
        Where Clause
        Clauses []Clause
        Limit int64
}

type Clause struct {
        Field string
        Condition string
        Value interface{}
        Connector string
        Parenthesis string
}

func panicIf(err error) {
	if err != nil {
		panic(err.Error())
	}
}
func getValue(v driver.Valuer) interface{} {
	o, err := v.Value()
	panicIf(err)

	return o
}

func (q *Query) And(field string, condition string, value interface{}) *Query {
        q.Clauses = append(q.Clauses, Clause{
                Field:     field,
                Condition: condition,
                Value:     value,
                Connector: "AND",
        })

        return q
}
func (q *Query) Or(field string, condition string, value interface{}) *Query {

        q.Clauses = append(q.Clauses, Clause{
                Field:     field,
                Condition: condition,
                Value:     value,
                Connector: "OR",
        })

        return q
}

func StrutToScannable (u interface{}) []interface{} {
	val := reflect.ValueOf(u).Elem()
//	fname := strings.ToLower(val.Type().Field(i).Name)

	v := make([]interface{}, val.NumField())
	for i := 0; i < val.NumField(); i++ {
		valueField := val.Field(i)
		v[i] = valueField.Addr().Interface()
	}

	return v
}

func(q *Query) Get() ([]Modeler, error) {
	var values []interface{}
	sql := "SELECT * FROM " + q.Schema +"." + q.Table + " WHERE "
	// TODO: We are asuming there is always a Where clause
	sql += fmt.Sprintf("%s %s $1", q.Where.Field, q.Where.Condition)
	values = append(values, q.Where.Value)
	for i, v := range q.Clauses {
		if v.Connector != "" {
			sql += " " + v.Connector + " "
		}
		sql += fmt.Sprintf("%s %s $%v", v.Field, v.Condition, i+2)
		values = append(values, v.Value)
	}

	rows, err := UsersDb.Query(sql, values...)
	switch q.Table {
{{.SwitchForGet}}
	}
	
	return results, err
}
 
